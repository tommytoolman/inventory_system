"""Reconcile schema after fixing model discovery

Revision ID: 3e399e66c3a0
Revises: e3326bf7ef11
Create Date: 2025-04-29 13:18:44.659586

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '3e399e66c3a0'
down_revision: Union[str, None] = 'e3326bf7ef11'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    productcondition_enum = postgresql.ENUM(
        'NEW', 'EXCELLENT', 'VERY_GOOD', 'GOOD', 'FAIR', 'POOR',
        name='productcondition', create_type=False
    )
    productcondition_enum.create(op.get_bind(), checkfirst=True)
    
    # op.drop_table('ebay_listings_old')

    # Check if indexes exist before dropping
    conn = op.get_bind()
    inspector = sa.inspect(conn)

    # Drop category_mappings index if exists
    if 'category_mappings' in inspector.get_table_names():
        indexes = [idx['name'] for idx in inspector.get_indexes('category_mappings')]
        if 'idx_category_mapping_unique' in indexes:
            op.drop_index('idx_category_mapping_unique', table_name='category_mappings')

    # Drop ebay_listings constraints and indexes if they exist
    if 'ebay_listings' in inspector.get_table_names():
        # Check constraints
        constraints = [c['name'] for c in inspector.get_unique_constraints('ebay_listings')]
        if 'ebay_listings_ebay_item_id_key' in constraints:
            op.drop_constraint('ebay_listings_ebay_item_id_key', 'ebay_listings', type_='unique')

        # Check indexes
        indexes = [idx['name'] for idx in inspector.get_indexes('ebay_listings')]
        if 'idx_ebay_listings_ebay_category_id' in indexes:
            op.drop_index('idx_ebay_listings_ebay_category_id', table_name='ebay_listings')
        if 'idx_ebay_listings_ebay_item_id' in indexes:
            op.drop_index('idx_ebay_listings_ebay_item_id', table_name='ebay_listings')
        if 'idx_ebay_listings_listing_status' in indexes:
            op.drop_index('idx_ebay_listings_listing_status', table_name='ebay_listings')
        if 'idx_ebay_listings_platform_id' in indexes:
            op.drop_index('idx_ebay_listings_platform_id', table_name='ebay_listings')

    # Only create indexes if the table and columns exist
    if 'ebay_listings' in inspector.get_table_names():
        columns = [col['name'] for col in inspector.get_columns('ebay_listings')]

        if 'ebay_category_id' in columns:
            op.create_index(op.f('ix_ebay_listings_ebay_category_id'), 'ebay_listings', ['ebay_category_id'], unique=False)
        if 'ebay_item_id' in columns:
            op.create_index(op.f('ix_ebay_listings_ebay_item_id'), 'ebay_listings', ['ebay_item_id'], unique=True)
        if 'id' in columns:
            op.create_index(op.f('ix_ebay_listings_id'), 'ebay_listings', ['id'], unique=False)
        if 'listing_status' in columns:
            op.create_index(op.f('ix_ebay_listings_listing_status'), 'ebay_listings', ['listing_status'], unique=False)

    # Check if foreign key exists before dropping
    if 'ebay_listings' in inspector.get_table_names():
        foreign_keys = [fk['name'] for fk in inspector.get_foreign_keys('ebay_listings')]
        if 'ebay_listings_platform_id_fkey' in foreign_keys:
            op.drop_constraint('ebay_listings_platform_id_fkey', 'ebay_listings', type_='foreignkey')

    op.create_foreign_key(None, 'ebay_listings', 'platform_common', ['platform_id'], ['id'])
    op.alter_column('products', 'condition',
            existing_type=sa.VARCHAR(),
            type_=productcondition_enum,
            nullable=False,
            postgresql_using='condition::productcondition') 
    op.drop_column('products', 'require_signature')
    op.drop_column('products', 'image_url')
    op.drop_column('products', 'length')
    op.drop_column('products', 'height')
    op.drop_column('products', 'width')
    op.drop_column('products', 'insurance')
    op.drop_column('products', 'shipping_rates')
    op.drop_column('products', 'platform_data')
    op.drop_column('products', 'weight')
    op.alter_column('shipping_profiles', 'description',
               existing_type=sa.TEXT(),
               type_=sa.String(),
               existing_nullable=True)

    # Check if constraint exists before dropping
    if 'shipping_profiles' in inspector.get_table_names():
        constraints = [c['name'] for c in inspector.get_unique_constraints('shipping_profiles')]
        if 'shipping_profiles_name_key' in constraints:
            op.drop_constraint('shipping_profiles_name_key', 'shipping_profiles', type_='unique')
    op.add_column('website_listings', sa.Column('created_at', sa.DateTime(), nullable=True))
    op.add_column('website_listings', sa.Column('updated_at', sa.DateTime(), nullable=True))
    op.add_column('website_listings', sa.Column('last_synced_at', sa.DateTime(), nullable=True))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Define this variable inside upgrade() AND downgrade() where needed
    productcondition_enum = postgresql.ENUM(
        'NEW', 'EXCELLENT', 'VERY_GOOD', 'GOOD', 'FAIR', 'POOR',
        name='productcondition', create_type=False
    )

    op.drop_column('website_listings', 'last_synced_at')
    op.drop_column('website_listings', 'updated_at')
    op.drop_column('website_listings', 'created_at')
    op.create_unique_constraint('shipping_profiles_name_key', 'shipping_profiles', ['name'])
    op.alter_column('shipping_profiles', 'description',
               existing_type=sa.String(),
               type_=sa.TEXT(),
               existing_nullable=True)
    op.add_column('products', sa.Column('weight', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('platform_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('shipping_rates', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('insurance', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('width', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('height', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('length', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('image_url', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.add_column('products', sa.Column('require_signature', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=True))
    op.alter_column('products', 'condition',
            existing_type=productcondition_enum,
            type_=sa.VARCHAR(),
            nullable=True,
            postgresql_using='condition::VARCHAR') # <<< ADD THIS ARGUMENT
    productcondition_enum.drop(op.get_bind(), checkfirst=False)
    op.drop_constraint(None, 'ebay_listings', type_='foreignkey')
    op.create_foreign_key('ebay_listings_platform_id_fkey', 'ebay_listings', 'platform_common', ['platform_id'], ['id'], ondelete='SET NULL')
    op.drop_index(op.f('ix_ebay_listings_listing_status'), table_name='ebay_listings')
    op.drop_index(op.f('ix_ebay_listings_id'), table_name='ebay_listings')
    op.drop_index(op.f('ix_ebay_listings_ebay_item_id'), table_name='ebay_listings')
    op.drop_index(op.f('ix_ebay_listings_ebay_category_id'), table_name='ebay_listings')
    op.create_index('idx_ebay_listings_platform_id', 'ebay_listings', ['platform_id'], unique=False)
    op.create_index('idx_ebay_listings_listing_status', 'ebay_listings', ['listing_status'], unique=False)
    op.create_index('idx_ebay_listings_ebay_item_id', 'ebay_listings', ['ebay_item_id'], unique=False)
    op.create_index('idx_ebay_listings_ebay_category_id', 'ebay_listings', ['ebay_category_id'], unique=False)
    op.create_unique_constraint('ebay_listings_ebay_item_id_key', 'ebay_listings', ['ebay_item_id'])
    op.create_index('idx_category_mapping_unique', 'category_mappings', ['source_platform', 'source_id', 'target_platform'], unique=True)
    op.create_table('ebay_listings_old',
    sa.Column('id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('platform_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('ebay_item_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ebay_category_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ebay_second_category_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('format', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('price', sa.NUMERIC(), autoincrement=False, nullable=True),
    sa.Column('quantity', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('payment_policy_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('return_policy_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('shipping_policy_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('item_specifics', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('package_weight', sa.NUMERIC(), autoincrement=False, nullable=True),
    sa.Column('package_dimensions', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('listing_duration', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('allow_offers', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('min_offer_amount', sa.NUMERIC(), autoincrement=False, nullable=True),
    sa.Column('listing_status', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('last_synced_at', postgresql.TIMESTAMP(), autoincrement=False, nullable=True)
    )
    # ### end Alembic commands ###
